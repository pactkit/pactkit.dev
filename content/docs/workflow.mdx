---
title: PDCA+ Workflow
description: The Plan-Do-Check-Act lifecycle
---

PactKit's core methodology is the **PDCA cycle** — Plan, Act, Check, Done — with quality gates at every stage.

## The Hierarchy of Truth

Before understanding the workflow, you must understand the governance model:

| Tier | Source | Role |
|------|--------|------|
| **Tier 1** | Specs (`docs/specs/*.md`) and Test Cases | **The Law** |
| **Tier 2** | Tests | Verification of the law |
| **Tier 3** | Implementation code | The mutable reality |

**Conflict resolution**: When Spec conflicts with code, **Spec wins** — modify the code. When Spec conflicts with tests, **Spec wins** — modify the tests. Code is never the source of truth.

## The Four Phases

### 1. Plan (`/project-plan`)

**Agent**: System Architect

The architect analyzes requirements and produces a Spec:

0. **Init Guard** — automatically checks if the project is initialized; runs `/project-init` if needed. Also verifies `pactkit.yaml` completeness and backfills missing sections.
1. **Clarify Gate** — auto-detects ambiguous requirements (missing quantitative metrics, unclear boundaries, vague scope). Generates structured questions and collects user answers before proceeding. Greenfield projects force-trigger clarification.
2. **Visual Scan** — run `visualize` to understand current codebase structure
3. **Logic Trace** — if modifying existing logic, uses the `pactkit-trace` skill
4. **Design** — update the high-level design diagram
5. **Spec** — create `docs/specs/{ID}.md` with RFC 2119 requirements and Given/When/Then acceptance criteria. **Spec Lint self-check** validates structural completeness before handoff.
6. **Board** — add a Story to the Sprint Board
7. **Context** — update `docs/product/context.md` for cross-session awareness

### 2. Act (`/project-act`)

**Agent**: Senior Developer

The developer implements code strictly per Spec, following TDD:

1. **Read Spec** — understand the requirements
2. **Spec Lint Gate** — non-AI structural validation of the Spec (metadata, required sections, Given/When/Then). Blocks on errors; continues with warnings.
3. **Consistency Check** — cross-references Spec requirements with Board tasks and ACs with Test Case scenarios. Advisory only (never blocks).
4. **Test First** — write unit tests (RED)
5. **Implement** — write code to make tests pass (GREEN), with a 5-iteration cap
6. **Lint Check** — run linter if CI config exists (e.g., `ruff check` for Python)
7. **Verify** — ensure the full test suite passes

<Callout type="info">
**Environment Bailout**: If a test fails with an environment error (missing package, connection refused), the developer distinguishes between project-internal modules (keep coding) and third-party dependencies (stop and report). This prevents false stops during normal development.
</Callout>

### 3. Check (`/project-check`)

**Agent**: QA Engineer

The QA engineer runs a 6-phase deep audit:

1. Security scan (OWASP baseline)
2. Test case generation (Gherkin scenarios)
3. Layer decision (API-level or browser-level testing)
4. Test execution
5. Spec alignment verification
6. PASS / FAIL verdict (includes Test Quality Gate for detecting tautological or over-mocked tests)

### 4. Done (`/project-done`)

**Agent**: Repo Maintainer

The maintainer finalizes the delivery:

1. **Clean** — remove temporary files
2. **Regression Gate** — run full test suite; stop if anything fails
3. **Lint Gate** — run linter with configurable blocking behavior
4. **Architecture Maintenance** — verify `system_design.mmd` component counts, refresh `rules.md` test invariants
5. **Hygiene** — confirm all Board tasks are checked off, append lessons to `lessons.md`
6. **Archive** — move completed Stories to archive
7. **Issue Closure** — close linked GitHub Issues (if `issue_tracker.provider: github`)
8. **Deploy Verify** — if a deployer exists, run it and smoke-test artifacts
9. **Release** (conditional) — version bump, snapshot, snapshot verification
10. **Commit** — conventional commit (`feat(scope): description`)
11. **Auto-PR** — generates structured PR body from Spec, Board, and test results. Includes Summary, Changes, Acceptance Criteria checklist, and Test Results. User confirmation required before creation.
12. **Context** — update `docs/product/context.md` for next session

## Session Context

PactKit maintains `docs/product/context.md` — an auto-generated file that gives the next session instant awareness of project state. It includes:

- Sprint status (in-progress, backlog, done counts)
- Recent completions (last 3 stories)
- Active branches
- Key decisions (last 5 lessons from `lessons.md`)
- Recommended next action

This file is updated by `/project-plan` and `/project-done`, and read at the start of every new session via the Core Protocol rule.

## Sprint Automation

Run the entire PDCA cycle in one command:

```bash
/project-sprint "Add user authentication"
```

This orchestrates all four phases automatically using a multi-agent team. Requires the Opus model for agent coordination.

## File Structure

| Path | Purpose |
|------|---------|
| `docs/specs/{ID}.md` | Requirement Specifications (The Law) |
| `docs/test_cases/{ID}_case.md` | Gherkin Acceptance Scenarios |
| `docs/product/sprint_board.md` | Sprint Board |
| `docs/product/context.md` | Auto-generated session context |
| `docs/product/prd.md` | Product Requirements Document |
| `docs/architecture/graphs/*.mmd` | Mermaid Architecture Diagrams |
| `docs/architecture/governance/rules.md` | Architecture decisions and invariants |
| `docs/architecture/governance/lessons.md` | Lessons learned (auto-appended by Done) |
| `docs/architecture/snapshots/` | Versioned architecture graph snapshots |
| `tests/unit/` | Unit Tests |
| `tests/e2e/` | E2E Integration Tests |
| `docs/product/archive/` | Archived Stories |
